import axios from 'axios';
import * as queryString from 'query-string';
import * as xml2js from 'xml2js';

export const YOUTUBE_VIDEO_INFO_URL: string = 'https://youtube.com/get_video_info?video_id={videoId}&el=detailpage';

export class YouTubeVideo{

    videoId: string
    title: string
    duration: number
    keywords: Array<string>
    channelId: string
    thumbnails: Array<Thumbnail>
    author: string
    viewCount: number
    avgRating: number
    isLive: boolean
    caption: Caption
    language: string
    streamingData: StreamingData

    constructor(data: any){
        this.videoId = data.player_response.videoDetails.videoId;
        this.title = data.player_response.videoDetails.title;
        this.duration = parseInt(data.player_response.videoDetails.lengthSeconds);
        this.keywords = data.player_response.videoDetails.keywords;
        this.channelId = data.player_response.videoDetails.channelId;
        this.thumbnails = data.player_response.videoDetails.thumbnail.thumbnails.map(thumbnail => new Thumbnail(thumbnail));
        this.author = data.player_response.videoDetails.author;
        this.viewCount = parseInt(data.player_response.videoDetails.viewCount);
        this.avgRating = parseFloat(data.avg_rating);
        this.isLive = data.player_response.videoDetails.isLiveContent;
        this.language = data.hl;
        if(data.player_response.captions)
            this.caption = new Caption(data.player_response.captions.playerCaptionsTracklistRenderer);
        if(data.player_response.streamingData)
            this.streamingData = new StreamingData(data.player_response.streamingData);
    }

    static async fetch(videoId: string): Promise<YouTubeVideo>{
        let { data } = await axios.get(YOUTUBE_VIDEO_INFO_URL.replace('{videoId}', videoId));
        let parseData: any = queryString.parse(data);
        parseData.adaptive_fmts = queryString.parse(parseData.adaptive_fmts as string) as any;
        parseData.fflags = queryString.parse(parseData.fflags as string) as any;
        parseData.player_response = JSON.parse(parseData.player_response as string);
        parseData.url_encoded_fmt_stream_map = queryString.parse(parseData.url_encoded_fmt_stream_map as string);
        return new YouTubeVideo(parseData);
    }

    static getVideoId(youtubeUrl: string){
        const regExp = /^.*((youtu.be\/)|(v\/)|(\/u\/\w\/)|(embed\/)|(watch\?))\??v?=?([^#\&\?]*).*/;
        const match = youtubeUrl.match(regExp);
        return (match&&match[7].length==11)? match[7] : false;
    }

}

export class Thumbnail {

    url: string
    width: string
    height: string
    type: 'HighRes' | 'Default' | 'Other'

    constructor(data: any){
        this.url = data.url;
        this.width = data.width;
        this.height = data.height;
        this.type = data.type || 'Other';
    }

}

export class Caption {
    
    tracks: Array<CaptionTrack>
    
    constructor(data: any){
        if(data.captionTracks)
            this.tracks = data.captionTracks.map(captionTrack => new CaptionTrack(captionTrack));
        else
            this.tracks = [];
    }

}

export class CaptionTrack {

    url: string
    language: CaptionTranslationLanguage
    autoGenerated: boolean
    rtl: boolean

    constructor(data: any){
        this.url = data.baseUrl;
        this.rtl = data.rtl;
        this.language = {
            code: data.languageCode,
            name: data.name.simpleText
        };
        this.autoGenerated = data.languageCode.indexOf('a.') === 0;
    }

    async captions(): Promise<Array<{ start: number, duration: number, text: string }>>{
        let { data } = await axios.get(this.url);
        return new Promise<Array<{ start: number, duration: number, text: string }>>((resolve, reject) => {
            xml2js.parseString(data, (err, parsedData) => {
                resolve(parsedData.transcript.text.map(text => {
                    return {
                        start: parseFloat(text.$.start),
                        duration: parseFloat(text.$.dur),
                        text: text._
                    }
                }));
            });
        });
    }

}

export interface CaptionTranslationLanguage {
    code: string
    name: string
}

export class StreamingData {

    expiresIn: number
    formats: Array<FileFormat>
    adaptiveFormats: Array<AdaptiveFileFormat>

    constructor(data: any){
        this.expiresIn = parseInt(data.expiresInSeconds);
        this.formats = data.formats.map(format => new FileFormat(format));
        this.adaptiveFormats = data.adaptiveFormats.map(format => new AdaptiveFileFormat(format));
    }
    
}

export class FileFormat {
    
    itag: number
    url: string
    mimeType: MimeType
    bitrate: number
    avgBitrate: number
    width: number
    height: number
    contentLength: number
    quality: string
    qualityLabel: string
    audioQuality: 'Low' | 'Medium' | 'High'
    audioSampleRate: number
    duration: number
    highReplication: boolean

    constructor(data: any){
        this.itag = data.itag;
        this.url = data.url;
        this.mimeType = new MimeType(data.mimeType);
        this.bitrate = data.bitrate;
        this.avgBitrate = data.averageBitrate;
        this.width = data.width;
        this.height = data.height;
        this.contentLength = parseInt(data.contentLength);
        this.quality = data.quality;
        this.qualityLabel = data.qualityLabel;
        this.audioQuality = data.audioQuality === 'AUDIO_QUALITY_LOW' ? 'Low' : data.audioQuality === 'AUDIO_QUALITY_MEDIUM' ? 'Medium' : 'High';
        this.audioSampleRate = parseInt(data.audioSampleRate);
        this.duration = (parseInt(data.approxDurationMs) / 1000);
        this.highReplication = data.highReplication;
    }

}

export class AdaptiveFileFormat extends FileFormat {

    isVideoOnly: boolean
    isAudioOnly: boolean
    fps: number

    constructor(data: any){
        super(data);
        this.isVideoOnly = !!data.qualityLabel;
        this.isAudioOnly = !!data.audioQuality;
    }

}

export class MimeType {
    
    type: string
    codec: string

    constructor(data: string){
        this.type = data.substr(0, data.indexOf(';'));
        this.codec = data.substr(data.indexOf(';') + 2).trim().replace('codecs="', '').replace('"', '');
    }

}